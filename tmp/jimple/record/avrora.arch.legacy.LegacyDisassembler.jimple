public class avrora.arch.legacy.LegacyDisassembler extends java.lang.Object implements avrora.arch.AbstractDisassembler
{
    int pc;
    int index;
    byte[] code;
    static final avrora.arch.legacy.LegacyRegister[] GPR_table;
    static final avrora.arch.legacy.LegacyRegister[] HGPR_table;
    static final avrora.arch.legacy.LegacyRegister[] MGPR_table;
    static final avrora.arch.legacy.LegacyRegister[] YZ_table;
    static final avrora.arch.legacy.LegacyRegister[] Z_table;
    static final avrora.arch.legacy.LegacyRegister[] EGPR_table;
    static final avrora.arch.legacy.LegacyRegister[] RDL_table;
    static final avrora.arch.legacy.LegacyRegister[] XYZ_table;

    public void <init>()
    {
        avrora.arch.legacy.LegacyDisassembler this;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        specialinvoke this.<java.lang.Object: void <init>()>();
        return;
    }

    public avrora.arch.AbstractInstr disassemble(int, int, byte[])
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int base, index;
        byte[] code;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        base := @parameter0: int;
        index := @parameter1: int;
        code := @parameter2: byte[];
        $r0 = virtualinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr disassembleLegacy(byte[],int,int)>(code, base, index);
        return $r0;
    }

    public avrora.arch.legacy.LegacyInstr disassembleLegacy(byte[], int, int)
    {
        avrora.arch.legacy.LegacyDisassembler this;
        byte[] code;
        int base, index, $i1, $i3;
        short word1;
        avrora.arch.legacy.LegacyDisassembler$InvalidInstruction e, $r1;
        byte $b0, $b2;
        avrora.arch.legacy.LegacyInstr $r0;
        avrora.arch.legacy.LegacyInstr$InvalidImmediate $r2, e;
        long tid_disassembleLegacy;
        java.lang.Thread thread_disassembleLegacy;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        code := @parameter0: byte[];
        base := @parameter1: int;
        index := @parameter2: int;
        thread_disassembleLegacy = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
        tid_disassembleLegacy = virtualinvoke thread_disassembleLegacy.<java.lang.Thread: long getId()>();

     label0:
        staticinvoke <edu.hkust.leap.monitor.RecordMonitor: void readBeforeArrayElem(java.lang.Object,int,long,java.lang.String,int,int,byte)>(code, 0, tid_disassembleLegacy, "avrora.arch.legacy.LegacyDisassembler", 90, index, $b0);
        $b0 = code[index];
        $i1 = index + 1;
        staticinvoke <edu.hkust.leap.monitor.RecordMonitor: void readBeforeArrayElem(java.lang.Object,int,long,java.lang.String,int,int,byte)>(code, 0, tid_disassembleLegacy, "avrora.arch.legacy.LegacyDisassembler", 90, $i1, $b2);
        $b2 = code[$i1];
        word1 = staticinvoke <cck.util.Arithmetic: short word(byte,byte)>($b0, $b2);
        this.<avrora.arch.legacy.LegacyDisassembler: int index> = index;
        $i3 = base + index;
        this.<avrora.arch.legacy.LegacyDisassembler: int pc> = $i3;
        this.<avrora.arch.legacy.LegacyDisassembler: byte[] code> = code;
        $r0 = virtualinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_root(int)>(word1);

     label1:
        return $r0;

     label2:
        $r1 := @caughtexception;
        e = $r1;
        return null;

     label3:
        $r2 := @caughtexception;
        e = $r2;
        return null;

        catch avrora.arch.legacy.LegacyDisassembler$InvalidInstruction from label0 to label1 with label2;
        catch avrora.arch.legacy.LegacyInstr$InvalidImmediate from label0 to label1 with label3;
    }

    private avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[], int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        avrora.arch.legacy.LegacyRegister[] table;
        int index, $i0, $i1, $i2;
        avrora.arch.legacy.LegacyRegister reg;
        avrora.arch.legacy.LegacyDisassembler$InvalidInstruction $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        table := @parameter0: avrora.arch.legacy.LegacyRegister[];
        index := @parameter1: int;
        if index < 0 goto label0;

        $i0 = lengthof table;
        if index < $i0 goto label1;

     label0:
        $r0 = new avrora.arch.legacy.LegacyDisassembler$InvalidInstruction;
        $i1 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(0);
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyDisassembler$InvalidInstruction: void <init>(avrora.arch.legacy.LegacyDisassembler,int,int)>(this, $i1, $i2);
        throw $r0;

     label1:
        reg = table[index];
        if reg != null goto label2;

        $r0 = new avrora.arch.legacy.LegacyDisassembler$InvalidInstruction;
        $i1 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(0);
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyDisassembler$InvalidInstruction: void <init>(avrora.arch.legacy.LegacyDisassembler,int,int)>(this, $i1, $i2);
        throw $r0;

     label2:
        return reg;
    }

    private int getWord(int)
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word, $i0, $i1, $i3;
        byte[] $r0, $r1;
        byte $b2, $b4;
        short $s5;
        long tid_getWord;
        java.lang.Thread thread_getWord;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word := @parameter0: int;
        thread_getWord = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
        tid_getWord = virtualinvoke thread_getWord.<java.lang.Thread: long getId()>();
        $r0 = this.<avrora.arch.legacy.LegacyDisassembler: byte[] code>;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int index>;
        $i1 = word * 2;
        $i0 = $i0 + $i1;
        staticinvoke <edu.hkust.leap.monitor.RecordMonitor: void readBeforeArrayElem(java.lang.Object,int,long,java.lang.String,int,int,byte)>($r0, 0, tid_getWord, "avrora.arch.legacy.LegacyDisassembler", 114, $i0, $b2);
        $b2 = $r0[$i0];
        $r1 = this.<avrora.arch.legacy.LegacyDisassembler: byte[] code>;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int index>;
        $i3 = word * 2;
        $i1 = $i1 + $i3;
        $i1 = $i1 + 1;
        staticinvoke <edu.hkust.leap.monitor.RecordMonitor: void readBeforeArrayElem(java.lang.Object,int,long,java.lang.String,int,int,byte)>($r1, 0, tid_getWord, "avrora.arch.legacy.LegacyDisassembler", 114, $i1, $b4);
        $b4 = $r1[$i1];
        $s5 = staticinvoke <cck.util.Arithmetic: short word(byte,byte)>($b2, $b4);
        return $s5;
    }

    private int getByte(int)
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word, $i0;
        byte[] $r0;
        byte $b1;
        short $s2;
        long tid_getByte;
        java.lang.Thread thread_getByte;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word := @parameter0: int;
        thread_getByte = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
        tid_getByte = virtualinvoke thread_getByte.<java.lang.Thread: long getId()>();
        $r0 = this.<avrora.arch.legacy.LegacyDisassembler: byte[] code>;
        $i0 = word * 2;
        staticinvoke <edu.hkust.leap.monitor.RecordMonitor: void readBeforeArrayElem(java.lang.Object,int,long,java.lang.String,int,int,byte)>($r0, 0, tid_getByte, "avrora.arch.legacy.LegacyDisassembler", 118, $i0, $b1);
        $b1 = $r0[$i0];
        $s2 = $b1 & 255;
        return $s2;
    }

    private int relative(int, int)
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int address, signbit, address, $i0, $i1;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        address := @parameter0: int;
        signbit := @parameter1: int;
        address = staticinvoke <cck.util.Arithmetic: int signExtend(int,int)>(address, signbit);
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i1 = address + $i0;
        $i1 = $i1 + 1;
        return $i1;
    }

    private avrora.arch.legacy.LegacyInstr decode_BST_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rr, bit, $i2;
        byte rr, bit;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$BST $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 8;
        if $i0 == 0 goto label0;

        return null;

     label0:
        rr = 0;
        bit = 0;
        $i1 = word1 >> 4;
        $i1 = $i1 & 31;
        rr = rr | $i1;
        $i1 = word1 & 7;
        bit = bit | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$BST;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$BST: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i2, $r2, bit);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_BLD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rr, bit, $i2;
        byte rr, bit;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$BLD $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 8;
        if $i0 == 0 goto label0;

        return null;

     label0:
        rr = 0;
        bit = 0;
        $i1 = word1 >> 4;
        $i1 = $i1 & 31;
        rr = rr | $i1;
        $i1 = word1 & 7;
        bit = bit | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$BLD;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$BLD: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i2, $r2, bit);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BST_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BLD_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRPL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRPL $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRPL;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRPL: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRGE_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRGE $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRGE;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRGE: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRTC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRTC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRTC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRTC: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRNE_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRNE $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRNE;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRNE: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRVC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRVC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRVC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRVC: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRID_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRID $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRID;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRID: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRHC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRHC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRHC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRHC: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRCC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRCC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRCC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRCC: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 7;
        tableswitch(value)
        {
            case 0: goto label7;
            case 1: goto label3;
            case 2: goto label0;
            case 3: goto label4;
            case 4: goto label1;
            case 5: goto label6;
            case 6: goto label2;
            case 7: goto label5;
            default: goto label8;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRPL_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRGE_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRTC_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRNE_0(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRVC_0(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRID_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRHC_0(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRCC_0(int)>(word1);
        return $r0;

     label8:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBRS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rr, bit, $i2;
        byte rr, bit;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SBRS $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 8;
        if $i0 == 0 goto label0;

        return null;

     label0:
        rr = 0;
        bit = 0;
        $i1 = word1 >> 4;
        $i1 = $i1 & 31;
        rr = rr | $i1;
        $i1 = word1 & 7;
        bit = bit | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$SBRS;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SBRS: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i2, $r2, bit);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBRC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rr, bit, $i2;
        byte rr, bit;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SBRC $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 8;
        if $i0 == 0 goto label0;

        return null;

     label0:
        rr = 0;
        bit = 0;
        $i1 = word1 >> 4;
        $i1 = $i1 & 31;
        rr = rr | $i1;
        $i1 = word1 & 7;
        bit = bit | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$SBRC;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SBRC: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i2, $r2, bit);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBRS_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBRC_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRMI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRMI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRMI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRMI: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRLT_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRLT $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRLT;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRLT: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRTS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRTS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRTS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRTS: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BREQ_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BREQ $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BREQ;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BREQ: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRVS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRVS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRVS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRVS: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRIE_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRIE $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRIE;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRIE: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRHS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRHS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRHS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRHS: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BRCS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$BRCS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 127;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$BRCS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 6);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BRCS: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_3(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 7;
        tableswitch(value)
        {
            case 0: goto label7;
            case 1: goto label3;
            case 2: goto label0;
            case 3: goto label4;
            case 4: goto label1;
            case 5: goto label6;
            case 6: goto label2;
            case 7: goto label5;
            default: goto label8;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRMI_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRLT_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRTS_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BREQ_0(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRVS_0(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRIE_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRHS_0(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BRCS_0(int)>(word1);
        return $r0;

     label8:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_4(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 10;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_1(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_2(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_3(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBCI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SBCI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SBCI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SBCI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ST_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$ST $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$ST;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$ST: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_ST_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$ST $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$ST;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$ST: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_5(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 15;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 8: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ST_1(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ST_2(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_LD_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LD_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_6(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 15;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 8: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LD_1(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LD_2(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_7(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 7;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_5(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_6(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_OUT_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, ior, rr, $i1;
        byte ior, rr;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$OUT $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ior = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 3;
        $i0 = $i0 << 4;
        ior = ior | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $i0 = word1 & 15;
        ior = ior | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$OUT;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$OUT: void <init>(int,int,avrora.arch.legacy.LegacyRegister)>($i1, ior, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_IN_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$IN $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 3;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$IN;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$IN: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_8(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 11;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_OUT_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_IN_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_CPI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$CPI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$CPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$CPI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ANDI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$ANDI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ANDI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ANDI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_RJMP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$RJMP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 & 4095;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$RJMP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 11);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$RJMP: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_OR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$OR $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$OR;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$OR: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_EOR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$EOR $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$EOR;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$EOR: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_MOV_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$MOV $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$MOV;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$MOV: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_AND_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$AND $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$AND;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$AND: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_9(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 10;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_OR_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_EOR_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_MOV_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_AND_0(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_RCALL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, target, $i1, $i2;
        byte target;
        avrora.arch.legacy.LegacyInstr$RCALL $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        target = 0;
        $i0 = word1 & 4095;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$RCALL;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $i2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int relative(int,int)>(target, 11);
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$RCALL: void <init>(int,int)>($i1, $i2);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, ior, bit, $i1;
        byte ior, bit;
        avrora.arch.legacy.LegacyInstr$SBI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ior = 0;
        bit = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 31;
        ior = ior | $i0;
        $i0 = word1 & 7;
        bit = bit | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$SBI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SBI: void <init>(int,int,int)>($i1, ior, bit);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBIC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, ior, bit, $i1;
        byte ior, bit;
        avrora.arch.legacy.LegacyInstr$SBIC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ior = 0;
        bit = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 31;
        ior = ior | $i0;
        $i0 = word1 & 7;
        bit = bit | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$SBIC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SBIC: void <init>(int,int,int)>($i1, ior, bit);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBIS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, ior, bit, $i1;
        byte ior, bit;
        avrora.arch.legacy.LegacyInstr$SBIS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ior = 0;
        bit = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 31;
        ior = ior | $i0;
        $i0 = word1 & 7;
        bit = bit | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$SBIS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SBIS: void <init>(int,int,int)>($i1, ior, bit);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CBI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, ior, bit, $i1;
        byte ior, bit;
        avrora.arch.legacy.LegacyInstr$CBI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ior = 0;
        bit = 0;
        $i0 = word1 >> 3;
        $i0 = $i0 & 31;
        ior = ior | $i0;
        $i0 = word1 & 7;
        bit = bit | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$CBI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CBI: void <init>(int,int,int)>($i1, ior, bit);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_10(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 8;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBI_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBIC_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBIS_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CBI_0(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBIW_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SBIW $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 6;
        $i0 = $i0 & 3;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 3;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SBIW;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] RDL_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SBIW: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ADIW_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$ADIW $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 6;
        $i0 = $i0 & 3;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 3;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ADIW;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] RDL_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ADIW: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_11(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 8;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBIW_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ADIW_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_ASR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rd, $i2;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$ASR $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 1 goto label0;

        return null;

     label0:
        rd = 0;
        $i1 = word1 >> 8;
        $i1 = $i1 & 1;
        $i1 = $i1 << 4;
        rd = rd | $i1;
        $i1 = word1 >> 4;
        $i1 = $i1 & 15;
        rd = rd | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$ASR;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ASR: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i2, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLI: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SES_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SES $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SES;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SES: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SPM_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SPM $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SPM;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SPM: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLC: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_WDR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$WDR $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$WDR;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$WDR: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLV_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLV $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLV;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLV: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_ICALL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$ICALL $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$ICALL;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$ICALL: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_RET_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$RET $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$RET;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$RET: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_12(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ICALL_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_RET_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEV_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SEV $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SEV;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEV: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SEI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SEI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEI: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLS $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLS: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_EICALL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$EICALL $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$EICALL;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$EICALL: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_RETI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$RETI $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$RETI;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$RETI: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_13(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_EICALL_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_RETI_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEN_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SEN $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SEN;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEN: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLH_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLH $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLH;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLH: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLZ_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLZ $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLZ;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLZ: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_LPM_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$LPM $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$LPM;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$LPM: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SET_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SET $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SET;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SET: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_EIJMP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$EIJMP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$EIJMP;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$EIJMP: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEZ_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$SEZ $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$SEZ;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEZ: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_14(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_EIJMP_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEZ_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_ELPM_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$ELPM $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$ELPM;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$ELPM: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLT_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLT $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLT;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLT: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_BREAK_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$BREAK $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$BREAK;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$BREAK: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SLEEP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SLEEP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SLEEP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SLEEP: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_CLN_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$CLN $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$CLN;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CLN: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEH_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$SEH $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$SEH;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEH: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_IJMP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$IJMP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$IJMP;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$IJMP: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_SEC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        avrora.arch.legacy.LegacyInstr$SEC $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $r0 = new avrora.arch.legacy.LegacyInstr$SEC;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$SEC: void <init>(int)>($i0);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_15(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_IJMP_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEC_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_16(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 4;
        value = $i0 & 31;
        tableswitch(value)
        {
            case 0: goto label23;
            case 1: goto label16;
            case 2: goto label11;
            case 3: goto label7;
            case 4: goto label1;
            case 5: goto label22;
            case 6: goto label15;
            case 7: goto label8;
            case 8: goto label3;
            case 9: goto label13;
            case 10: goto label21;
            case 11: goto label5;
            case 12: goto label9;
            case 13: goto label12;
            case 14: goto label18;
            case 15: goto label0;
            case 16: goto label6;
            case 17: goto label10;
            case 18: goto label24;
            case 19: goto label24;
            case 20: goto label24;
            case 21: goto label24;
            case 22: goto label24;
            case 23: goto label24;
            case 24: goto label20;
            case 25: goto label19;
            case 26: goto label4;
            case 27: goto label24;
            case 28: goto label14;
            case 29: goto label17;
            case 30: goto label2;
            default: goto label24;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLI_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SES_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SPM_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLC_0(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_WDR_0(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLV_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_12(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEV_0(int)>(word1);
        return $r0;

     label8:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEI_0(int)>(word1);
        return $r0;

     label9:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLS_0(int)>(word1);
        return $r0;

     label10:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_13(int)>(word1);
        return $r0;

     label11:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEN_0(int)>(word1);
        return $r0;

     label12:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLH_0(int)>(word1);
        return $r0;

     label13:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLZ_0(int)>(word1);
        return $r0;

     label14:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LPM_0(int)>(word1);
        return $r0;

     label15:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SET_0(int)>(word1);
        return $r0;

     label16:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_14(int)>(word1);
        return $r0;

     label17:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ELPM_0(int)>(word1);
        return $r0;

     label18:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLT_0(int)>(word1);
        return $r0;

     label19:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_BREAK_0(int)>(word1);
        return $r0;

     label20:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SLEEP_0(int)>(word1);
        return $r0;

     label21:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CLN_0(int)>(word1);
        return $r0;

     label22:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SEH_0(int)>(word1);
        return $r0;

     label23:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_15(int)>(word1);
        return $r0;

     label24:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_JMP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, word2, $i0, target, $i1;
        byte target;
        avrora.arch.legacy.LegacyInstr$JMP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        word2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(1);
        target = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        $i0 = $i0 << 17;
        target = target | $i0;
        $i0 = word1 & 1;
        $i0 = $i0 << 16;
        target = target | $i0;
        $i0 = word2 & 65535;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$JMP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$JMP: void <init>(int,int)>($i1, target);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_INC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$INC $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$INC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$INC: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_SWAP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SWAP $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SWAP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SWAP: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_17(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_INC_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SWAP_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_ROR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$ROR $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ROR;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ROR: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LSR_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LSR $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LSR;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LSR: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_18(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ROR_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LSR_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_CALL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, word2, $i0, target, $i1;
        byte target;
        avrora.arch.legacy.LegacyInstr$CALL $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        word2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(1);
        target = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        $i0 = $i0 << 17;
        target = target | $i0;
        $i0 = word1 & 1;
        $i0 = $i0 << 16;
        target = target | $i0;
        $i0 = word2 & 65535;
        target = target | $i0;
        $r0 = new avrora.arch.legacy.LegacyInstr$CALL;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$CALL: void <init>(int,int)>($i1, target);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_DEC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1, rd, $i2;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$DEC $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 1;
        if $i0 == 0 goto label0;

        return null;

     label0:
        rd = 0;
        $i1 = word1 >> 4;
        $i1 = $i1 & 31;
        rd = rd | $i1;
        $r1 = new avrora.arch.legacy.LegacyInstr$DEC;
        $i2 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$DEC: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i2, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_NEG_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$NEG $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$NEG;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$NEG: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_COM_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$COM $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$COM;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$COM: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_19(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_NEG_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_COM_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_20(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 1;
        value = $i0 & 7;
        tableswitch(value)
        {
            case 0: goto label7;
            case 1: goto label3;
            case 2: goto label0;
            case 3: goto label4;
            case 4: goto label1;
            case 5: goto label6;
            case 6: goto label2;
            case 7: goto label5;
            default: goto label8;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ASR_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_16(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_JMP_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_17(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_18(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CALL_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_DEC_0(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_19(int)>(word1);
        return $r0;

     label8:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_21(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_11(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_20(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_MUL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$MUL $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$MUL;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$MUL: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPD_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPD $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_PUSH_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$PUSH $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$PUSH;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$PUSH: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPI $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPI_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPI $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPI_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPI $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPD $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_STPD_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$STPD $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_ST_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, $i1;
        byte rr;
        avrora.arch.legacy.LegacyRegister $r0, $r3;
        avrora.arch.legacy.LegacyRegister[] $r1;
        avrora.arch.legacy.LegacyInstr$ST $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$ST;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$ST: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r0, $r3);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_STS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, word2, $i0, rr, addr, $i1;
        byte addr, rr;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$STS $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        word2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(1);
        addr = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $i0 = word2 & 65535;
        addr = addr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$STS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$STS: void <init>(int,int,avrora.arch.legacy.LegacyRegister)>($i1, addr, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_22(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 15;
        tableswitch(value)
        {
            case 0: goto label8;
            case 1: goto label4;
            case 2: goto label0;
            case 3: goto label9;
            case 4: goto label9;
            case 5: goto label9;
            case 6: goto label9;
            case 7: goto label9;
            case 8: goto label9;
            case 9: goto label3;
            case 10: goto label6;
            case 11: goto label9;
            case 12: goto label7;
            case 13: goto label2;
            case 14: goto label5;
            case 15: goto label1;
            default: goto label9;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPD_2(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_PUSH_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPI_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPI_1(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPI_2(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPD_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STPD_1(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ST_0(int)>(word1);
        return $r0;

     label8:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STS_0(int)>(word1);
        return $r0;

     label9:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_POP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$POP $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$POP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$POP: void <init>(int,avrora.arch.legacy.LegacyRegister)>($i1, $r2);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LPMD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd, z;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$LPMD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        z = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LPMD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] Z_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, z);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LPMD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ELPMPI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$ELPMPI $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ELPMPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] Z_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ELPMPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPD_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPI $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPI_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPI $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ELPMD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$ELPMD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ELPMD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] Z_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ELPMD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPI_2(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPI $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDPD_1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDPD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r3;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDPD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDPD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r3);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LPMPI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, $i1;
        byte rd, z;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$LPMPI $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        z = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LPMPI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] Z_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, z);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LPMPI: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, word2, $i0, rd, addr, $i1;
        byte rd, addr;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDS $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        word2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: int getWord(int)>(1);
        rd = 0;
        addr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $i0 = word2 & 65535;
        addr = addr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDS: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, addr);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_23(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        value = word1 & 15;
        tableswitch(value)
        {
            case 0: goto label12;
            case 1: goto label8;
            case 2: goto label4;
            case 3: goto label13;
            case 4: goto label1;
            case 5: goto label11;
            case 6: goto label7;
            case 7: goto label2;
            case 8: goto label13;
            case 9: goto label6;
            case 10: goto label10;
            case 11: goto label13;
            case 12: goto label3;
            case 13: goto label5;
            case 14: goto label9;
            case 15: goto label0;
            default: goto label13;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_POP_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LPMD_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ELPMPI_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LD_0(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPD_2(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPI_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPI_1(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ELPMD_0(int)>(word1);
        return $r0;

     label8:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPI_2(int)>(word1);
        return $r0;

     label9:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPD_0(int)>(word1);
        return $r0;

     label10:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDPD_1(int)>(word1);
        return $r0;

     label11:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LPMPI_0(int)>(word1);
        return $r0;

     label12:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDS_0(int)>(word1);
        return $r0;

     label13:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_24(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_22(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_23(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_25(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 10;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_10(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_21(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_MUL_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_24(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_ORI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$ORI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ORI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ORI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_SUB_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$SUB $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SUB;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SUB: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_CP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$CP $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$CP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$CP: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ADC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$ADC $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ADC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ADC: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_CPSE_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$CPSE $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$CPSE;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$CPSE: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_26(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 10;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SUB_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CP_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ADC_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CPSE_0(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$LDI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_SUBI_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, imm, rd, $i1;
        byte rd, imm;
        avrora.arch.legacy.LegacyRegister[] $r0;
        avrora.arch.legacy.LegacyInstr$SUBI $r1;
        avrora.arch.legacy.LegacyRegister $r2;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        imm = 0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 15;
        $i0 = $i0 << 4;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SUBI;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SUBI: void <init>(int,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_SBC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$SBC $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$SBC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$SBC: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_CPC_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$CPC $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$CPC;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$CPC: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_ADD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rr, rd, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$ADD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 9;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rr = rr | $i0;
        $i0 = word1 >> 8;
        $i0 = $i0 & 1;
        $i0 = $i0 << 4;
        rd = rd | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$ADD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$ADD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_MULS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$MULS $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$MULS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$MULS: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_MOVW_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$MOVW $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 15;
        rd = rd | $i0;
        $i0 = word1 & 15;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$MOVW;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] EGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] EGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$MOVW: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_FMULSU_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$FMULSU $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 7;
        rd = rd | $i0;
        $i0 = word1 & 7;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$FMULSU;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$FMULSU: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_FMULS_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$FMULS $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 7;
        rd = rd | $i0;
        $i0 = word1 & 7;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$FMULS;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$FMULS: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_27(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 3;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_FMULSU_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_FMULS_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_FMUL_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$FMUL $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 7;
        rd = rd | $i0;
        $i0 = word1 & 7;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$FMUL;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$FMUL: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_MULSU_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, rd, rr, $i1;
        byte rd, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        avrora.arch.legacy.LegacyInstr$MULSU $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        rr = 0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 7;
        rd = rd | $i0;
        $i0 = word1 & 7;
        rr = rr | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$MULSU;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, rr);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$MULSU: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister)>($i1, $r2, $r4);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_28(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 3;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_FMUL_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_MULSU_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_29(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 7;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_27(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_28(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_NOP_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0, $i1;
        avrora.arch.legacy.LegacyInstr$NOP $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 & 255;
        if $i0 == 0 goto label0;

        return null;

     label0:
        $r0 = new avrora.arch.legacy.LegacyInstr$NOP;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyInstr$NOP: void <init>(int)>($i1);
        return $r0;
    }

    private avrora.arch.legacy.LegacyInstr decode_30(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 8;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_MULS_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_MOVW_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_29(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_NOP_0(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_31(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 10;
        value = $i0 & 3;
        tableswitch(value)
        {
            case 0: goto label3;
            case 1: goto label1;
            case 2: goto label0;
            case 3: goto label2;
            default: goto label4;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBC_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CPC_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ADD_0(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_30(int)>(word1);
        return $r0;

     label4:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_root0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 12;
        value = $i0 & 15;
        tableswitch(value)
        {
            case 0: goto label14;
            case 1: goto label11;
            case 2: goto label7;
            case 3: goto label4;
            case 4: goto label1;
            case 5: goto label13;
            case 6: goto label10;
            case 7: goto label5;
            case 8: goto label2;
            case 9: goto label9;
            case 10: goto label15;
            case 11: goto label3;
            case 12: goto label6;
            case 13: goto label8;
            case 14: goto label12;
            case 15: goto label0;
            default: goto label15;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_4(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SBCI_0(int)>(word1);
        return $r0;

     label2:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_7(int)>(word1);
        return $r0;

     label3:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_8(int)>(word1);
        return $r0;

     label4:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_CPI_0(int)>(word1);
        return $r0;

     label5:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ANDI_0(int)>(word1);
        return $r0;

     label6:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_RJMP_0(int)>(word1);
        return $r0;

     label7:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_9(int)>(word1);
        return $r0;

     label8:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_RCALL_0(int)>(word1);
        return $r0;

     label9:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_25(int)>(word1);
        return $r0;

     label10:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_ORI_0(int)>(word1);
        return $r0;

     label11:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_26(int)>(word1);
        return $r0;

     label12:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDI_0(int)>(word1);
        return $r0;

     label13:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_SUBI_0(int)>(word1);
        return $r0;

     label14:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_31(int)>(word1);
        return $r0;

     label15:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_STD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, imm, $i0, rr, ar, $i1;
        byte ar, imm, rr;
        avrora.arch.legacy.LegacyRegister[] $r0, $r1;
        boolean $z0;
        avrora.arch.legacy.LegacyInstr$STD $r2;
        avrora.arch.legacy.LegacyRegister $r3, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        ar = 0;
        imm = 0;
        rr = 0;
        $z0 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(word1, 13);
        imm = staticinvoke <cck.util.Arithmetic: int setBit(int,int,boolean)>(imm, 5, $z0);
        $i0 = word1 >> 10;
        $i0 = $i0 & 3;
        $i0 = $i0 << 3;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rr = rr | $i0;
        $z0 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(word1, 3);
        ar = staticinvoke <cck.util.Arithmetic: int setBit(int,int,boolean)>(ar, 0, $z0);
        $i0 = word1 & 7;
        imm = imm | $i0;
        $r2 = new avrora.arch.legacy.LegacyInstr$STD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] YZ_table>;
        $r3 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, ar);
        $r1 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r1, rr);
        specialinvoke $r2.<avrora.arch.legacy.LegacyInstr$STD: void <init>(int,avrora.arch.legacy.LegacyRegister,int,avrora.arch.legacy.LegacyRegister)>($i1, $r3, imm, $r4);
        return $r2;
    }

    private avrora.arch.legacy.LegacyInstr decode_LDD_0(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, imm, $i0, rd, ar, $i1;
        byte rd, ar, imm;
        avrora.arch.legacy.LegacyRegister[] $r0, $r3;
        boolean $z0;
        avrora.arch.legacy.LegacyInstr$LDD $r1;
        avrora.arch.legacy.LegacyRegister $r2, $r4;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        rd = 0;
        ar = 0;
        imm = 0;
        $z0 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(word1, 13);
        imm = staticinvoke <cck.util.Arithmetic: int setBit(int,int,boolean)>(imm, 5, $z0);
        $i0 = word1 >> 10;
        $i0 = $i0 & 3;
        $i0 = $i0 << 3;
        imm = imm | $i0;
        $i0 = word1 >> 4;
        $i0 = $i0 & 31;
        rd = rd | $i0;
        $z0 = staticinvoke <cck.util.Arithmetic: boolean getBit(int,int)>(word1, 3);
        ar = staticinvoke <cck.util.Arithmetic: int setBit(int,int,boolean)>(ar, 0, $z0);
        $i0 = word1 & 7;
        imm = imm | $i0;
        $r1 = new avrora.arch.legacy.LegacyInstr$LDD;
        $i1 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        $r0 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table>;
        $r2 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r0, rd);
        $r3 = <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] YZ_table>;
        $r4 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister getReg(avrora.arch.legacy.LegacyRegister[],int)>($r3, ar);
        specialinvoke $r1.<avrora.arch.legacy.LegacyInstr$LDD: void <init>(int,avrora.arch.legacy.LegacyRegister,avrora.arch.legacy.LegacyRegister,int)>($i1, $r2, $r4, imm);
        return $r1;
    }

    private avrora.arch.legacy.LegacyInstr decode_32(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 9;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label1;
            case 1: goto label0;
            default: goto label2;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_STD_0(int)>(word1);
        return $r0;

     label1:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_LDD_0(int)>(word1);
        return $r0;

     label2:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_33(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 12;
        value = $i0 & 1;
        lookupswitch(value)
        {
            case 0: goto label0;
            default: goto label1;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_32(int)>(word1);
        return $r0;

     label1:
        return null;
    }

    private avrora.arch.legacy.LegacyInstr decode_root1(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, value, $i0;
        avrora.arch.legacy.LegacyInstr $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        $i0 = word1 >> 14;
        value = $i0 & 3;
        lookupswitch(value)
        {
            case 2: goto label0;
            default: goto label1;
        };

     label0:
        $r0 = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_33(int)>(word1);
        return $r0;

     label1:
        return null;
    }

    avrora.arch.legacy.LegacyInstr decode_root(int) throws avrora.arch.legacy.LegacyDisassembler$InvalidInstruction
    {
        avrora.arch.legacy.LegacyDisassembler this;
        int word1, $i0;
        null_type i;
        avrora.arch.legacy.LegacyInstr i;
        avrora.arch.legacy.LegacyDisassembler$InvalidInstruction $r0;

        this := @this: avrora.arch.legacy.LegacyDisassembler;
        word1 := @parameter0: int;
        i = null;
        i = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_root0(int)>(word1);
        if i == null goto label0;

        return i;

     label0:
        i = specialinvoke this.<avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyInstr decode_root1(int)>(word1);
        if i == null goto label1;

        return i;

     label1:
        $r0 = new avrora.arch.legacy.LegacyDisassembler$InvalidInstruction;
        $i0 = this.<avrora.arch.legacy.LegacyDisassembler: int pc>;
        specialinvoke $r0.<avrora.arch.legacy.LegacyDisassembler$InvalidInstruction: void <init>(avrora.arch.legacy.LegacyDisassembler,int,int)>(this, word1, $i0);
        throw $r0;
    }

    static void <clinit>()
    {
        avrora.arch.legacy.LegacyRegister $r0;
        avrora.arch.legacy.LegacyRegister[] $r1;

        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[32];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R0>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R1>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R2>;
        $r1[2] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R3>;
        $r1[3] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R4>;
        $r1[4] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R5>;
        $r1[5] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R6>;
        $r1[6] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R7>;
        $r1[7] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R8>;
        $r1[8] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R9>;
        $r1[9] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R10>;
        $r1[10] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R11>;
        $r1[11] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R12>;
        $r1[12] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R13>;
        $r1[13] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R14>;
        $r1[14] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R15>;
        $r1[15] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R16>;
        $r1[16] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R17>;
        $r1[17] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R18>;
        $r1[18] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R19>;
        $r1[19] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R20>;
        $r1[20] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R21>;
        $r1[21] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R22>;
        $r1[22] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R23>;
        $r1[23] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R24>;
        $r1[24] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R25>;
        $r1[25] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R26>;
        $r1[26] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R27>;
        $r1[27] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R28>;
        $r1[28] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R29>;
        $r1[29] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R30>;
        $r1[30] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R31>;
        $r1[31] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] GPR_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[16];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R16>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R17>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R18>;
        $r1[2] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R19>;
        $r1[3] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R20>;
        $r1[4] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R21>;
        $r1[5] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R22>;
        $r1[6] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R23>;
        $r1[7] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R24>;
        $r1[8] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R25>;
        $r1[9] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R26>;
        $r1[10] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R27>;
        $r1[11] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R28>;
        $r1[12] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R29>;
        $r1[13] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R30>;
        $r1[14] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R31>;
        $r1[15] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] HGPR_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[8];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R16>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R17>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R18>;
        $r1[2] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R19>;
        $r1[3] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R20>;
        $r1[4] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R21>;
        $r1[5] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R22>;
        $r1[6] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R23>;
        $r1[7] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] MGPR_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[2];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        $r1[1] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] YZ_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[1];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1[0] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] Z_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[16];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R0>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R2>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R4>;
        $r1[2] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R6>;
        $r1[3] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R8>;
        $r1[4] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R10>;
        $r1[5] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R12>;
        $r1[6] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R14>;
        $r1[7] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R16>;
        $r1[8] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R18>;
        $r1[9] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R20>;
        $r1[10] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R22>;
        $r1[11] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R24>;
        $r1[12] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R26>;
        $r1[13] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R28>;
        $r1[14] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R30>;
        $r1[15] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] EGPR_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[4];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R24>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R26>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R28>;
        $r1[2] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister R30>;
        $r1[3] = $r0;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] RDL_table> = $r1;
        $r1 = newarray (avrora.arch.legacy.LegacyRegister)[4];
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister X>;
        $r1[0] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Y>;
        $r1[1] = $r0;
        $r0 = <avrora.arch.legacy.LegacyRegister: avrora.arch.legacy.LegacyRegister Z>;
        $r1[2] = $r0;
        $r1[3] = null;
        <avrora.arch.legacy.LegacyDisassembler: avrora.arch.legacy.LegacyRegister[] XYZ_table> = $r1;
        return;
    }
}
