    * Step 1: transformer
          o javac example.Example.java
          o java -cp .:transformer.jar edu.hkust.leap.Main example.Example
          o Two new directories "tmp/runtime" and "tmp/replay" will be created, which contain the transformed runtime version and replay version of example.Example.class, respectively.

    * Step 2: recorder
          o java -cp ./tmp/runtime:recorder.jar edu.hkust.leap.Main 1 example.Example
          o Here, the input parameter "1" is the number of SPEs reported in Step 1. 
          o If it crashes, a replay driver will be generated by LEAP to reproduce the failure.

    * Step 3: replayer
          o javac -cp .:replayer.jar:./tmp/replay ReplayDriver.java
          o java -cp .:replayer.jar:./tmp/replay ReplayDriver
          
          
          1 exception: "crashed_with" as a flag, manually injecting the "crashed_with.equals(e)"
          2 synchornized method, the synchronized is directly removed (because do not depend on such functions..), and entermonitorAfter stub is injected.
          3 notify() are removed in replay.
          4 enter synchronized method, exit are seperated in Visitor.java and AddIn...Visitor.java
          5 static var-> int is determined statically in the instrumentation and hardcoded,
          it is also okay using the static var name as index, hashmap, but slow..
          6 record: use the classpath to map the transformer/tmp/record/, and save monitor data at the hooking thread
          also, generate drivers for exception or non-exception(?)
          7 thread.getName is in a fixed set, while thread.getID() can include the JVM threads. so the set is not fixed.
          ,IN one run, the recorded IDs are {9,10}, in replay, ID canbe {13, 14}, no way to make use of old information.
          So use getName as the identification of the same thread cross different runs. It is fixed. 
          {Thread-0, THread1}, next run is still {Thread0, thread1}.
          9 the replayer can  not be implemented in a simpler way like thread.wait()
          because t.wait(), t.notify needs synchronization, besides, t.notify may not wake up the 
          t.wait(), this is what I found in debugging, while o.wait(), o.notify does not have such problems, so strange.
          10 I finished the instrumentation, specially, classConstant are added to hashmap at 
          the main method of main class. Other places seem not proper, like the clinit-baf body problem, not sure
          this knowledge is fixed inside the code, instead of dumping and relaoding between runs.
          11 I transform the synchronized method to blocks, the key is standard goto and exceptional end
          for original exceptions, you do not need to see them at all. Another problem is, for static synchronzied method
          maybe the locallock is not initialized yet before comign to the exception handling.
          
            
          
          